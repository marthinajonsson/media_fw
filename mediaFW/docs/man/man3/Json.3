.TH "Json" 3 "Mon Oct 15 2018" "mediaFW" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Json \- JSON (JavaScript Object Notation)\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBBuiltStyledStreamWriter\fP"
.br
.ti -1c
.RI "class \fBCharReader\fP"
.br
.ti -1c
.RI "class \fBCharReaderBuilder\fP"
.br
.RI "Build a \fBCharReader\fP implementation\&. "
.ti -1c
.RI "struct \fBCommentStyle\fP"
.br
.RI "Scoped enums are not available until C++11\&. "
.ti -1c
.RI "class \fBException\fP"
.br
.ti -1c
.RI "class \fBFeatures\fP"
.br
.RI "Configuration passed to reader and writer\&. This configuration object can be used to force the \fBReader\fP or Writer to behave in a standard conforming way\&. "
.ti -1c
.RI "class \fBLogicError\fP"
.br
.ti -1c
.RI "class \fBOurCharReader\fP"
.br
.ti -1c
.RI "class \fBOurFeatures\fP"
.br
.ti -1c
.RI "class \fBOurReader\fP"
.br
.ti -1c
.RI "class \fBPath\fP"
.br
.RI "Experimental and untested: represents a 'path' to access a node\&. "
.ti -1c
.RI "class \fBPathArgument\fP"
.br
.RI "Experimental and untested: represents an element of the 'path' to access a node\&. "
.ti -1c
.RI "class \fBReader\fP"
.br
.RI "Unserialize a \fCJSON\fP document into a \fBValue\fP\&. "
.ti -1c
.RI "class \fBRuntimeError\fP"
.br
.ti -1c
.RI "class \fBStaticString\fP"
.br
.RI "Lightweight wrapper to tag static string\&. "
.ti -1c
.RI "class \fBStreamWriter\fP"
.br
.ti -1c
.RI "class \fBStreamWriterBuilder\fP"
.br
.RI "Build a \fBStreamWriter\fP implementation\&. "
.ti -1c
.RI "class \fBValue\fP"
.br
.RI "Represents a \fCJSON\fP value\&. "
.ti -1c
.RI "class \fBValueConstIterator\fP"
.br
.RI "const iterator for object and array value\&. "
.ti -1c
.RI "class \fBValueIterator\fP"
.br
.RI "Iterator for object and array value\&. "
.ti -1c
.RI "class \fBValueIteratorBase\fP"
.br
.RI "base class for \fBValue\fP iterators\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBInt\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBUInt\fP"
.br
.ti -1c
.RI "typedef int64_t \fBInt64\fP"
.br
.ti -1c
.RI "typedef uint64_t \fBUInt64\fP"
.br
.ti -1c
.RI "typedef Int64 \fBLargestInt\fP"
.br
.ti -1c
.RI "typedef UInt64 \fBLargestUInt\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBArrayIndex\fP"
.br
.ti -1c
.RI "typedef char \fBUIntToStringBuffer\fP[\fBuintToStringBufferSize\fP]"
.br
.ti -1c
.RI "typedef std::auto_ptr< \fBCharReader\fP > \fBCharReaderPtr\fP"
.br
.ti -1c
.RI "typedef std::auto_ptr< \fBStreamWriter\fP > \fBStreamWriterPtr\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBValueType\fP { \fBnullValue\fP = 0, \fBintValue\fP, \fBuintValue\fP, \fBrealValue\fP, \fBstringValue\fP, \fBbooleanValue\fP, \fBarrayValue\fP, \fBobjectValue\fP }
.RI "Type of the value held by a Value object\&. ""
.br
.ti -1c
.RI "enum \fBCommentPlacement\fP { \fBcommentBefore\fP = 0, \fBcommentAfterOnSameLine\fP, \fBcommentAfter\fP, \fBnumberOfCommentPlacement\fP }"
.br
.ti -1c
.RI "enum \fBPrecisionType\fP { \fBsignificantDigits\fP = 0, \fBdecimalPlaces\fP }
.RI "Type of precision for formatting of real values\&. ""
.br
.ti -1c
.RI "enum { \fBuintToStringBufferSize\fP = 3 * sizeof(LargestUInt) + 1 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "JSONCPP_NORETURN void \fBthrowRuntimeError\fP (JSONCPP_STRING const &msg)"
.br
.RI "used internally "
.ti -1c
.RI "JSONCPP_NORETURN void \fBthrowLogicError\fP (JSONCPP_STRING const &msg)"
.br
.RI "used internally "
.ti -1c
.RI "void \fBswap\fP (\fBValue\fP &a, \fBValue\fP &b)"
.br
.ti -1c
.RI "bool JSON_API \fBparseFromStream\fP (\fBCharReader::Factory\fP const &, JSONCPP_ISTREAM &, \fBValue\fP *root, std::string *errs)"
.br
.ti -1c
.RI "JSON_API JSONCPP_ISTREAM & \fBoperator>>\fP (JSONCPP_ISTREAM &, \fBValue\fP &)"
.br
.RI "Read from 'sin' into 'root'\&. "
.ti -1c
.RI "JSONCPP_STRING JSON_API \fBwriteString\fP (\fBStreamWriter::Factory\fP const &factory, \fBValue\fP const &root)"
.br
.RI "Write into stringstream, then return string, for convenience\&. A \fBStreamWriter\fP will be created from the factory, used, and then deleted\&. "
.ti -1c
.RI "class \fBJSONCPP_DEPRECATED\fP ('Use \fBStreamWriter\fP instead') JSON_API Writer"
.br
.RI "Abstract class for writers\&. "
.ti -1c
.RI "class JSONCPP_DEPRECATED('Use \fBStreamWriterBuilder\fP instead') JSON_API FastWriter class JSONCPP_DEPRECATED('Use \fBStreamWriterBuilder\fP instead') JSON_API StyledWriter class \fBJSONCPP_DEPRECATED\fP ('Use \fBStreamWriterBuilder\fP instead') JSON_API StyledStreamWriter"
.br
.RI "Outputs a \fBValue\fP in \fCJSON\fP format without formatting (not human friendly)\&. "
.ti -1c
.RI "JSONCPP_STRING JSON_API \fBvalueToString\fP (Int value)"
.br
.ti -1c
.RI "JSONCPP_STRING JSON_API \fBvalueToString\fP (UInt value)"
.br
.ti -1c
.RI "JSONCPP_STRING JSON_API \fBvalueToString\fP (LargestInt value)"
.br
.ti -1c
.RI "JSONCPP_STRING JSON_API \fBvalueToString\fP (LargestUInt value)"
.br
.ti -1c
.RI "JSONCPP_STRING JSON_API \fBvalueToString\fP (double value, unsigned int precision=\fBValue::defaultRealPrecision\fP, \fBPrecisionType\fP precisionType=PrecisionType::significantDigits)"
.br
.ti -1c
.RI "JSONCPP_STRING JSON_API \fBvalueToString\fP (bool value)"
.br
.ti -1c
.RI "JSONCPP_STRING JSON_API \fBvalueToQuotedString\fP (const char *value)"
.br
.ti -1c
.RI "JSON_API JSONCPP_OSTREAM & \fBoperator<<\fP (JSONCPP_OSTREAM &, const \fBValue\fP &root)"
.br
.RI "Output using the StyledStreamWriter\&. "
.ti -1c
.RI "static char \fBgetDecimalPoint\fP ()"
.br
.ti -1c
.RI "static JSONCPP_STRING \fBcodePointToUTF8\fP (unsigned int cp)"
.br
.RI "Converts a unicode code-point to UTF-8\&. "
.ti -1c
.RI "static void \fBuintToString\fP (LargestUInt value, char *&current)"
.br
.ti -1c
.RI "template<typename Iter > Iter \fBfixNumericLocale\fP (Iter begin, Iter end)"
.br
.ti -1c
.RI "template<typename Iter > void \fBfixNumericLocaleInput\fP (Iter begin, Iter end)"
.br
.ti -1c
.RI "template<typename Iter > Iter \fBfixZerosInTheEnd\fP (Iter begin, Iter end)"
.br
.ti -1c
.RI "static void \fBgetValidReaderKeys\fP (std::set< JSONCPP_STRING > *valid_keys)"
.br
.ti -1c
.RI "bool \fBparseFromStream\fP (\fBCharReader::Factory\fP const &fact, JSONCPP_ISTREAM &sin, \fBValue\fP *root, JSONCPP_STRING *errs)"
.br
.ti -1c
.RI "template<typename T , typename U > static bool \fBInRange\fP (double d, T min, U max)"
.br
.ti -1c
.RI "static char * \fBduplicateStringValue\fP (const char *value, size_t length)"
.br
.ti -1c
.RI "static char * \fBduplicateAndPrefixStringValue\fP (const char *value, unsigned int length)"
.br
.ti -1c
.RI "static void \fBdecodePrefixedString\fP (bool isPrefixed, char const *prefixed, unsigned *length, char const **value)"
.br
.ti -1c
.RI "static void \fBreleasePrefixedStringValue\fP (char *value)"
.br
.ti -1c
.RI "static void \fBreleaseStringValue\fP (char *value, unsigned)"
.br
.ti -1c
.RI "static bool \fBIsIntegral\fP (double d)"
.br
.ti -1c
.RI "static bool \fBisAnyCharRequiredQuoting\fP (char const *s, size_t n)"
.br
.ti -1c
.RI "static unsigned int \fButf8ToCodepoint\fP (const char *&s, const char *e)"
.br
.ti -1c
.RI "static JSONCPP_STRING \fBtoHex16Bit\fP (unsigned int x)"
.br
.ti -1c
.RI "static JSONCPP_STRING \fBvalueToQuotedStringN\fP (const char *value, unsigned length)"
.br
.ti -1c
.RI "static void \fBgetValidWriterKeys\fP (std::set< JSONCPP_STRING > *valid_keys)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const char \fBhex2\fP []"
.br
.in -1c
.SH "Detailed Description"
.PP 
JSON (JavaScript Object Notation)\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIuintToStringBufferSize \fP\fP
Constant that specify the size of the buffer that must be passed to uintToString\&. 
.SS "enum \fBJson::CommentPlacement\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIcommentBefore \fP\fP
a comment placed on the line before a value 
.TP
\fB\fIcommentAfterOnSameLine \fP\fP
a comment just after a value on the same line 
.TP
\fB\fIcommentAfter \fP\fP
a comment on the line after a value (only make sense for 
.TP
\fB\fInumberOfCommentPlacement \fP\fP
root value) 
.SS "enum \fBJson::PrecisionType\fP"

.PP
Type of precision for formatting of real values\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIsignificantDigits \fP\fP
we set max number of significant digits in string 
.TP
\fB\fIdecimalPlaces \fP\fP
we set max number of digits after '\&.' in string 
.SS "enum \fBJson::ValueType\fP"

.PP
Type of the value held by a \fBValue\fP object\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fInullValue \fP\fP
'null' value 
.TP
\fB\fIintValue \fP\fP
signed integer value 
.TP
\fB\fIuintValue \fP\fP
unsigned integer value 
.TP
\fB\fIrealValue \fP\fP
double value 
.TP
\fB\fIstringValue \fP\fP
UTF-8 string value\&. 
.TP
\fB\fIbooleanValue \fP\fP
bool value 
.TP
\fB\fIarrayValue \fP\fP
array value (ordered list) 
.TP
\fB\fIobjectValue \fP\fP
object value (collection of name/value pairs)\&. 
.SH "Function Documentation"
.PP 
.SS "static char* Json::duplicateStringValue (const char * value, size_t length)\fC [inline]\fP, \fC [static]\fP"
Duplicates the specified string value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Pointer to the string to duplicate\&. Must be zero-terminated if length is 'unknown'\&. 
.br
\fIlength\fP Length of the value\&. if equals to unknown, then it will be computed using strlen(value)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer on the duplicate instance of string\&. 
.RE
.PP

.SS "template<typename Iter > Iter Json::fixNumericLocale (Iter begin, Iter end)"
Change ',' to '\&.' everywhere in buffer\&.
.PP
We had a sophisticated way, but it did not work in WinCE\&. 
.PP
\fBSee also:\fP
.RS 4
https://github.com/open-source-parsers/jsoncpp/pull/9 
.RE
.PP

.SS "template<typename Iter > Iter Json::fixZerosInTheEnd (Iter begin, Iter end)"
Return iterator that would be the new end of the range [begin,end), if we were to delete zeros in the end of string, but not the last zero before '\&.'\&. 
.SS "class Json::JSONCPP_DEPRECATED ('Use \fBStreamWriter\fP instead')"

.PP
Abstract class for writers\&. 
.PP
\fBDeprecated\fP
.RS 4
Use \fBStreamWriter\fP\&. (And really, this is an implementation detail\&.) 
.RE
.PP

.SS "class JSONCPP_DEPRECATED ('Use \fBStreamWriterBuilder\fP instead') JSON_API FastWriter class JSONCPP_DEPRECATED ('Use \fBStreamWriterBuilder\fP instead') JSON_API StyledWriter class Json::JSONCPP_DEPRECATED ('Use \fBStreamWriterBuilder\fP instead')"

.PP
Outputs a \fBValue\fP in \fCJSON\fP format without formatting (not human friendly)\&. The JSON document is written in a single line\&. It is not intended for 'human' consumption, but may be useful to support feature such as RPC where bandwidth is limited\&. 
.PP
\fBSee also:\fP
.RS 4
\fBReader\fP, \fBValue\fP 
.RE
.PP
\fBDeprecated\fP
.RS 4
Use \fBStreamWriterBuilder\fP\&. 
.RE
.PP
Writes a \fBValue\fP in \fCJSON\fP format in a human friendly way\&.
.PP
The rules for line break and indent are as follow:
.IP "\(bu" 2
Object value:
.IP "  \(bu" 4
if empty then print {} without indent and line break
.IP "  \(bu" 4
if not empty the print '{', line break & indent, print one value per line and then unindent and line break and print '}'\&.
.PP

.IP "\(bu" 2
Array value:
.IP "  \(bu" 4
if empty then print [] without indent and line break
.IP "  \(bu" 4
if the array contains no object value, empty array or some other value types, and all the values fit on one lines, then print the array on a single line\&.
.IP "  \(bu" 4
otherwise, it the values do not fit on one line, or the array contains object or non empty array, then print one value per line\&.
.PP

.PP
.PP
If the \fBValue\fP have comments then they are outputed according to their \fBCommentPlacement\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBReader\fP, \fBValue\fP, \fBValue::setComment()\fP 
.RE
.PP
\fBDeprecated\fP
.RS 4
Use \fBStreamWriterBuilder\fP\&. 
.RE
.PP
Writes a \fBValue\fP in \fCJSON\fP format in a human friendly way, to a stream rather than to a string\&.
.PP
The rules for line break and indent are as follow:
.IP "\(bu" 2
Object value:
.IP "  \(bu" 4
if empty then print {} without indent and line break
.IP "  \(bu" 4
if not empty the print '{', line break & indent, print one value per line and then unindent and line break and print '}'\&.
.PP

.IP "\(bu" 2
Array value:
.IP "  \(bu" 4
if empty then print [] without indent and line break
.IP "  \(bu" 4
if the array contains no object value, empty array or some other value types, and all the values fit on one lines, then print the array on a single line\&.
.IP "  \(bu" 4
otherwise, it the values do not fit on one line, or the array contains object or non empty array, then print one value per line\&.
.PP

.PP
.PP
If the \fBValue\fP have comments then they are outputed according to their \fBCommentPlacement\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBReader\fP, \fBValue\fP, \fBValue::setComment()\fP 
.RE
.PP
\fBDeprecated\fP
.RS 4
Use \fBStreamWriterBuilder\fP\&. 
.RE
.PP

.PP
\fBParameters:\fP
.RS 4
\fIindentation\fP Each level will be indented by this amount extra\&.
.RE
.PP
Serialize a \fBValue\fP in \fCJSON\fP format\&. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP Stream to write to\&. (Can be ostringstream, e\&.g\&.) 
.br
\fIroot\fP \fBValue\fP to serialize\&. 
.RE
.PP
\fBNote:\fP
.RS 4
There is no point in deriving from Writer, since write() should not return a value\&.
.RE
.PP

.SS "JSONCPP_OSTREAM & Json::operator<< (JSONCPP_OSTREAM & sout, const \fBValue\fP & root)"

.PP
Output using the StyledStreamWriter\&. 
.PP
\fBSee also:\fP
.RS 4
\fBJson::operator>>()\fP 
.RE
.PP

.SS "JSONCPP_ISTREAM & Json::operator>> (JSONCPP_ISTREAM & sin, \fBValue\fP & root)"

.PP
Read from 'sin' into 'root'\&. Always keep comments from the input JSON\&.
.PP
This can be used to read a file into a particular sub-object\&. For example: 
.PP
.nf
Json::Value root;
cin >> root["dir"]["file"];
cout << root;

.fi
.PP
 Result: 
.PP
.nf
{
"dir": {
    "file": {
    // The input stream JSON would be nested here.
    }
}
}

.fi
.PP
 
.PP
\fBExceptions:\fP
.RS 4
\fIstd::exception\fP on parse error\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBJson::operator<<()\fP 
.RE
.PP

.SS "bool JSON_API Json::parseFromStream (\fBCharReader::Factory\fP const &, JSONCPP_ISTREAM &, \fBValue\fP * root, std::string * errs)"
Consume entire stream and use its begin/end\&. Someday we might have a real StreamReader, but for now this is convenient\&. 
.SS "static void Json::releasePrefixedStringValue (char * value)\fC [inline]\fP, \fC [static]\fP"
Free the string duplicated by \fBduplicateStringValue()\fP/duplicateAndPrefixStringValue()\&. 
.SS "static void Json::uintToString (LargestUInt value, char *& current)\fC [inline]\fP, \fC [static]\fP"
Converts an unsigned integer to string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Unsigned integer to convert to string 
.br
\fIcurrent\fP Input/Output string buffer\&. Must have at least uintToStringBufferSize chars free\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const char Json::hex2[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= "000102030405060708090a0b0c0d0e0f"
                           "101112131415161718191a1b1c1d1e1f"
                           "202122232425262728292a2b2c2d2e2f"
                           "303132333435363738393a3b3c3d3e3f"
                           "404142434445464748494a4b4c4d4e4f"
                           "505152535455565758595a5b5c5d5e5f"
                           "606162636465666768696a6b6c6d6e6f"
                           "707172737475767778797a7b7c7d7e7f"
                           "808182838485868788898a8b8c8d8e8f"
                           "909192939495969798999a9b9c9d9e9f"
                           "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
                           "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
                           "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
                           "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
                           "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
                           "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for mediaFW from the source code\&.
