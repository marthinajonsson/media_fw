.TH "Json::Reader" 3 "Mon Oct 15 2018" "mediaFW" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Json::Reader \- Unserialize a \fCJSON\fP document into a \fBValue\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <json\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBErrorInfo\fP"
.br
.ti -1c
.RI "struct \fBStructuredError\fP"
.br
.RI "An error tagged with where in the JSON text it was encountered\&. "
.ti -1c
.RI "class \fBToken\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef char \fBChar\fP"
.br
.ti -1c
.RI "typedef const Char * \fBLocation\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBReader\fP ()"
.br
.RI "Constructs a \fBReader\fP allowing all features for parsing\&. "
.ti -1c
.RI "\fBReader\fP (const \fBFeatures\fP &features)"
.br
.RI "Constructs a \fBReader\fP allowing the specified feature set for parsing\&. "
.ti -1c
.RI "bool \fBparse\fP (const std::string &document, \fBValue\fP &root, bool collectComments=true)"
.br
.RI "Read a \fBValue\fP from a \fCJSON\fP document\&. "
.ti -1c
.RI "bool \fBparse\fP (const char *beginDoc, const char *endDoc, \fBValue\fP &root, bool collectComments=true)"
.br
.RI "Read a \fBValue\fP from a \fCJSON\fP document\&. "
.ti -1c
.RI "bool \fBparse\fP (JSONCPP_ISTREAM &is, \fBValue\fP &root, bool collectComments=true)"
.br
.RI "Parse from input stream\&. "
.ti -1c
.RI "JSONCPP_STRING \fBgetFormatedErrorMessages\fP () const"
.br
.RI "Returns a user friendly string that list errors in the parsed document\&. "
.ti -1c
.RI "JSONCPP_STRING \fBgetFormattedErrorMessages\fP () const"
.br
.RI "Returns a user friendly string that list errors in the parsed document\&. "
.ti -1c
.RI "std::vector< \fBStructuredError\fP > \fBgetStructuredErrors\fP () const"
.br
.RI "Returns a vector of structured erros encounted while parsing\&. "
.ti -1c
.RI "bool \fBpushError\fP (const \fBValue\fP &value, const JSONCPP_STRING &message)"
.br
.RI "Add a semantic error message\&. "
.ti -1c
.RI "bool \fBpushError\fP (const \fBValue\fP &value, const JSONCPP_STRING &message, const \fBValue\fP &extra)"
.br
.RI "Add a semantic error message with extra context\&. "
.ti -1c
.RI "bool \fBgood\fP () const"
.br
.RI "Return whether there are any errors\&. "
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBTokenType\fP { \fBtokenEndOfStream\fP = 0, \fBtokenObjectBegin\fP, \fBtokenObjectEnd\fP, \fBtokenArrayBegin\fP, \fBtokenArrayEnd\fP, \fBtokenString\fP, \fBtokenNumber\fP, \fBtokenTrue\fP, \fBtokenFalse\fP, \fBtokenNull\fP, \fBtokenArraySeparator\fP, \fBtokenMemberSeparator\fP, \fBtokenComment\fP, \fBtokenError\fP }"
.br
.ti -1c
.RI "typedef std::deque< \fBErrorInfo\fP > \fBErrors\fP"
.br
.ti -1c
.RI "typedef std::stack< \fBValue\fP * > \fBNodes\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "bool \fBreadToken\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "void \fBskipSpaces\fP ()"
.br
.ti -1c
.RI "bool \fBmatch\fP (Location pattern, int patternLength)"
.br
.ti -1c
.RI "bool \fBreadComment\fP ()"
.br
.ti -1c
.RI "bool \fBreadCStyleComment\fP ()"
.br
.ti -1c
.RI "bool \fBreadCppStyleComment\fP ()"
.br
.ti -1c
.RI "bool \fBreadString\fP ()"
.br
.ti -1c
.RI "void \fBreadNumber\fP ()"
.br
.ti -1c
.RI "bool \fBreadValue\fP ()"
.br
.ti -1c
.RI "bool \fBreadObject\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBreadArray\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeNumber\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeNumber\fP (\fBToken\fP &token, \fBValue\fP &decoded)"
.br
.ti -1c
.RI "bool \fBdecodeString\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeString\fP (\fBToken\fP &token, JSONCPP_STRING &decoded)"
.br
.ti -1c
.RI "bool \fBdecodeDouble\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeDouble\fP (\fBToken\fP &token, \fBValue\fP &decoded)"
.br
.ti -1c
.RI "bool \fBdecodeUnicodeCodePoint\fP (\fBToken\fP &token, Location &current, Location end, unsigned int &unicode)"
.br
.ti -1c
.RI "bool \fBdecodeUnicodeEscapeSequence\fP (\fBToken\fP &token, Location &current, Location end, unsigned int &unicode)"
.br
.ti -1c
.RI "bool \fBaddError\fP (const JSONCPP_STRING &message, \fBToken\fP &token, Location extra=0)"
.br
.ti -1c
.RI "bool \fBrecoverFromError\fP (TokenType skipUntilToken)"
.br
.ti -1c
.RI "bool \fBaddErrorAndRecover\fP (const JSONCPP_STRING &message, \fBToken\fP &token, TokenType skipUntilToken)"
.br
.ti -1c
.RI "void \fBskipUntilSpace\fP ()"
.br
.ti -1c
.RI "\fBValue\fP & \fBcurrentValue\fP ()"
.br
.ti -1c
.RI "Char \fBgetNextChar\fP ()"
.br
.ti -1c
.RI "void \fBgetLocationLineAndColumn\fP (Location location, int &line, int &column) const"
.br
.ti -1c
.RI "JSONCPP_STRING \fBgetLocationLineAndColumn\fP (Location location) const"
.br
.ti -1c
.RI "void \fBaddComment\fP (Location begin, Location end, \fBCommentPlacement\fP placement)"
.br
.ti -1c
.RI "void \fBskipCommentTokens\fP (\fBToken\fP &token)"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBcontainsNewLine\fP (Location begin, Location end)"
.br
.ti -1c
.RI "static JSONCPP_STRING \fBnormalizeEOL\fP (Location begin, Location end)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "Nodes \fBnodes_\fP"
.br
.ti -1c
.RI "Errors \fBerrors_\fP"
.br
.ti -1c
.RI "JSONCPP_STRING \fBdocument_\fP"
.br
.ti -1c
.RI "Location \fBbegin_\fP"
.br
.ti -1c
.RI "Location \fBend_\fP"
.br
.ti -1c
.RI "Location \fBcurrent_\fP"
.br
.ti -1c
.RI "Location \fBlastValueEnd_\fP"
.br
.ti -1c
.RI "\fBValue\fP * \fBlastValue_\fP"
.br
.ti -1c
.RI "JSONCPP_STRING \fBcommentsBefore_\fP"
.br
.ti -1c
.RI "\fBFeatures\fP \fBfeatures_\fP"
.br
.ti -1c
.RI "bool \fBcollectComments_\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Unserialize a \fCJSON\fP document into a \fBValue\fP\&. 


.PP
\fBDeprecated\fP
.RS 4
Use \fBCharReader\fP and \fBCharReaderBuilder\fP\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "JSONCPP_STRING Json::Reader::getFormatedErrorMessages () const"

.PP
Returns a user friendly string that list errors in the parsed document\&. 
.PP
\fBReturns:\fP
.RS 4
Formatted error message with the list of errors with their location in the parsed document\&. An empty string is returned if no error occurred during parsing\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
Use \fBgetFormattedErrorMessages()\fP instead (typo fix)\&. 
.RE
.PP

.SS "JSONCPP_STRING Json::Reader::getFormattedErrorMessages () const"

.PP
Returns a user friendly string that list errors in the parsed document\&. 
.PP
\fBReturns:\fP
.RS 4
Formatted error message with the list of errors with their location in the parsed document\&. An empty string is returned if no error occurred during parsing\&. 
.RE
.PP

.SS "std::vector< \fBReader::StructuredError\fP > Json::Reader::getStructuredErrors () const"

.PP
Returns a vector of structured erros encounted while parsing\&. 
.PP
\fBReturns:\fP
.RS 4
A (possibly empty) vector of \fBStructuredError\fP objects\&. Currently only one error can be returned, but the caller should tolerate multiple errors\&. This can occur if the parser recovers from a non-fatal parse error and then encounters additional errors\&. 
.RE
.PP

.SS "bool Json::Reader::good () const"

.PP
Return whether there are any errors\&. 
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if there are no errors to report \fCfalse\fP if errors have occurred\&. 
.RE
.PP

.SS "bool Json::Reader::parse (const std::string & document, \fBValue\fP & root, bool collectComments = \fCtrue\fP)"

.PP
Read a \fBValue\fP from a \fCJSON\fP document\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdocument\fP UTF-8 encoded string containing the document to read\&. 
.br
\fIroot\fP [out] Contains the root value of the document if it was successfully parsed\&. 
.br
\fIcollectComments\fP \fCtrue\fP to collect comment and allow writing them back during serialization, \fCfalse\fP to discard comments\&. This parameter is ignored if \fBFeatures::allowComments_\fP is \fCfalse\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the document was successfully parsed, \fCfalse\fP if an error occurred\&. 
.RE
.PP

.SS "bool Json::Reader::parse (const char * beginDoc, const char * endDoc, \fBValue\fP & root, bool collectComments = \fCtrue\fP)"

.PP
Read a \fBValue\fP from a \fCJSON\fP document\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbeginDoc\fP Pointer on the beginning of the UTF-8 encoded string of the document to read\&. 
.br
\fIendDoc\fP Pointer on the end of the UTF-8 encoded string of the document to read\&. Must be >= beginDoc\&. 
.br
\fIroot\fP [out] Contains the root value of the document if it was successfully parsed\&. 
.br
\fIcollectComments\fP \fCtrue\fP to collect comment and allow writing them back during serialization, \fCfalse\fP to discard comments\&. This parameter is ignored if \fBFeatures::allowComments_\fP is \fCfalse\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the document was successfully parsed, \fCfalse\fP if an error occurred\&. 
.RE
.PP

.SS "bool Json::Reader::parse (JSONCPP_ISTREAM & is, \fBValue\fP & root, bool collectComments = \fCtrue\fP)"

.PP
Parse from input stream\&. 
.PP
\fBSee also:\fP
.RS 4
Json::operator>>(std::istream&, Json::Value&)\&. 
.RE
.PP

.SS "bool Json::Reader::pushError (const \fBValue\fP & value, const JSONCPP_STRING & message)"

.PP
Add a semantic error message\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP JSON \fBValue\fP location associated with the error 
.br
\fImessage\fP The error message\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the error was successfully added, \fCfalse\fP if the \fBValue\fP offset exceeds the document size\&. 
.RE
.PP

.SS "bool Json::Reader::pushError (const \fBValue\fP & value, const JSONCPP_STRING & message, const \fBValue\fP & extra)"

.PP
Add a semantic error message with extra context\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP JSON \fBValue\fP location associated with the error 
.br
\fImessage\fP The error message\&. 
.br
\fIextra\fP Additional JSON \fBValue\fP location to contextualize the error 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the error was successfully added, \fCfalse\fP if either \fBValue\fP offset exceeds the document size\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for mediaFW from the source code\&.
